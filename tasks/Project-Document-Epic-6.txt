
Project Document: Epic 6 - Core Email Sending & Processing Pipeline
Last Updated: October 27, 2025
1. Epic Overview
1.1. Objective
To develop the end-to-end, asynchronous pipeline for scheduling, sending, and tracking every email dispatched by the PenguinMails platform. This epic will implement the scheduler that creates sending jobs, the worker that processes these jobs via SMTP, and the tracking system to process engagement events like opens and clicks.
1.2. Description
This is the heart of the PenguinMails application—the engine that performs the core business function. Building on the Redis foundation from Epic 1, we will create a sophisticated, decoupled system. A "Campaign Scheduler" service will scan the database for campaigns that are due and push sending tasks into a Redis queue. A separate, dedicated "Email Processor" worker (running on a different server) will pull tasks from this queue, assemble the email, and send it via the user's configured SMTP provider. Finally, we will build a high-performance tracking endpoint to receive engagement webhooks (opens/clicks) and push them into another queue for asynchronous processing, ensuring the main application remains fast and responsive.
1.3. Prerequisites
	•	All previous epics (1-5) must be substantially complete. Specifically:
	•	Redis is configured and accessible ([CORE-4]).
	•	The database schemas for campaigns, leads, templates, email_accounts, and inbox_message_refs are defined and migrated.
	•	The platform can manage tenants, companies, and email_accounts.
	•	
	•	A clear understanding of how to run a separate Node.js process for the worker, distinct from the Next.js API server.

2. Milestones & Tickets
Milestone 1: Job Enqueueing and Campaign Scheduling
	•	Goal: To create the "producer" side of the pipeline. This involves building the logic that determines when an email needs to be sent and pushing a corresponding job into the Redis queue.
Ticket ID
Title
Description
Acceptance Criteria (AC)
[MAIL-1.1]
Define Drizzle Schemas for Email Pipeline
Create/finalize the Drizzle schemas for campaigns, leads, templates, email_accounts, campaign_sequence_steps, inbox_message_refs, and inbox_message_content. Generate and apply the migrations.
1. All required schema files exist in /lib/db/schema. <br> 2. The schemas correctly define all columns, types, and relationships. <br> 3. Running npm run db:migrate successfully creates all tables in the database.
[MAIL-1.2]
Define Zod Schema for Job Payloads
In /lib/schemas, create a jobs.schemas.ts file. Define and export a Zod schema (emailJobPayloadSchema) for the JSON payload of an email sending job. It must include fields like tenantId, campaignId, leadId, stepId, and emailAccountId.
1. The jobs.schemas.ts file is created. <br> 2. The emailJobPayloadSchema is defined and correctly validates a sample job object.
[MAIL-1.3]
Implement the Campaign Scheduler Service
In /lib/services/scheduler.service.ts, create a function enqueueDueCampaigns(). This function will query the database for all active campaigns and their sequence steps, calculate which leads are due for a send based on scheduling rules and step delays, and prepare a list of job payloads.
1. The function correctly queries the database to find campaigns that are active and past their scheduled_at time. <br> 2. It correctly calculates the delay for subsequent steps (e.g., wait_duration_hours). <br> 3. It returns an array of structured job payload objects, ready to be enqueued.
[MAIL-1.4]
Create a Cron Job to Run the Scheduler
Create a protected API route at /api/cron/scheduler/route.ts. This endpoint will be triggered by an external scheduler (e.g., Vercel Cron Jobs). It will call enqueueDueCampaigns() and then loop through the resulting payloads, pushing each one as a JSON string into the queue:email-sending Redis list using LPUSH.
1. The API route is created and protected. <br> 2. When triggered, it successfully retrieves due jobs from the scheduler service. <br> 3. It pushes each job payload into the correct Redis list. <br> 4. It logs a summary (e.g., "Enqueued 150 email jobs").

Milestone 2: The Email Sending Worker
	•	Goal: To build the "consumer" side of the pipeline. This is a standalone worker process that will pull jobs from Redis and perform the actual email sending.
Ticket ID
Title
Description
Acceptance Criteria (AC)
[MAIL-2.1]
Set Up Standalone Worker Project
Create a new, simple Node.js/TypeScript project in a /worker sub-directory of the main repository. This project will share package.json dependencies but have its own tsconfig.json and entry point (index.ts). It must be able to connect to both PostgreSQL (via Drizzle) and Redis.
1. A /worker directory exists with a separate entry point. <br> 2. The worker can be started with a script like npm run worker:start. <br> 3. The worker successfully connects to both the database and Redis upon startup.
[MAIL-2.2]
Implement the Worker's Main Loop
In the worker's entry point, implement an infinite loop that uses the Redis BRPOP command to wait for and pull a single job from the queue:email-sending list. This command should block until a job is available.
1. The worker starts and logs "Waiting for jobs...". <br> 2. When a job is pushed to the Redis list (from Milestone 1), the worker immediately receives it and logs the payload.
[MAIL-2.3]
Implement Email Assembly Logic
Create a function assembleEmail(jobPayload). This function will take the parsed job payload, query the database using Drizzle to fetch the full lead, template, and email_account details. It will then perform variable replacement (e.g., {{firstName}}) in the template's subject and body.
1. The function successfully fetches all required data from the database. <br> 2. It correctly replaces variables in the subject and body with the lead's data. <br> 3. It returns a final email object with from, to, subject, and html fields.
[MAIL-2.4]
Implement SMTP Sending with Nodemailer
Install nodemailer. Create a function sendEmail(emailObject, smtpSettings). This function will create a Nodemailer transport using the smtp_settings from the user's email_account and dispatch the email.
1. nodemailer is a dependency. <br> 2. The function correctly configures the Nodemailer transport with the host, port, user, and password from the database. <br> 3. It successfully sends an email to a test inbox (e.g., using a service like Ethereal or Mailtrap for development).
[MAIL-2.5]
Integrate Sending Logic and Database Logging
Combine the previous steps in the worker's main loop. After successfully sending an email, the worker must create a new record in the inbox_message_refs table with direction: 'outbound' and status: 'sent'. It should also handle send failures gracefully and implement a basic retry mechanism.
1. A successfully sent email results in a new record in inbox_message_refs. <br> 2. The record is correctly linked to the tenant_id, campaign_id, lead_id, etc. <br> 3. If an SMTP connection fails, the job is not lost and can be retried later.

Milestone 3: Engagement Tracking
	•	Goal: To build the high-performance webhook that captures open and click events and queues them for asynchronous processing.
Ticket ID
Title
Description
Acceptance Criteria (AC)
[MAIL-3.1]
Implement Tracking Token Generation
When assembling an email in the worker ([MAIL-2.3]), generate a secure JWT (JSON Web Token) for each trackable link and for the open-tracking pixel. This token must contain the necessary metadata (tenantId, leadId, campaignId, stepId).
1. A JWT library (e.g., jsonwebtoken) is installed. <br> 2. A secret key for signing tokens is added to environment variables. <br> 3. The email assembly logic correctly embeds links like /api/track/click?token=[JWT] and an image tag like <img src="/api/track/open?token=[JWT]">.
[MAIL-3.2]
Create the Public Tracking API Route (/api/track/[...slug])
Create a public, high-performance API route handler that will capture all tracking requests. It must be configured for edge execution if possible (e.g., Vercel Edge Functions) for minimal latency.
1. An API route at /app/api/track/[...slug]/route.ts is created. <br> 2. It can handle both GET /api/track/open and GET /api/track/click requests.
[MAIL-3.3]
Implement the Open Tracking Handler
For requests to /api/track/open, the endpoint will: 1. Verify the JWT. 2. Push a job with the token's payload to a new Redis list: queue:analytics-processing. 3. Immediately return a 1x1 transparent pixel image (Content-Type: image/gif). This must be extremely fast.
1. The endpoint validates the JWT and rejects invalid tokens. <br> 2. It successfully pushes a job to the queue:analytics-processing Redis list. <br> 3. It returns a valid image response with the correct headers to prevent browser errors.
[MAIL-3.4]
Implement the Click Tracking Handler
For requests to /api/track/click, the endpoint will: 1. Verify the JWT. 2. Push a job to the queue:analytics-processing list. 3. Immediately issue a 302 Found redirect to the original destination URL, which should also be encoded in the JWT.
1. The endpoint validates the JWT. <br> 2. It successfully pushes a job to the queue:analytics-processing list. <br> 3. It correctly redirects the user's browser to the final intended URL.
[MAIL-3.5]
Create the Analytics Processing Worker (Stub)
In the /worker project, create a new function that listens to the queue:analytics-processing list. For this epic, the worker only needs to pull the job and log the event (e.g., "Received open event for lead XYZ"). The actual database update will be handled in the Analytics epic.
1. The worker can listen to a second Redis queue simultaneously. <br> 2. When an open or click event is tracked, the worker receives the job and logs its payload.

